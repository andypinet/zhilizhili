{"version":3,"names":[],"mappings":"","sources":["about/my_class/road.js"],"sourcesContent":["export default function(superClass) {\n\t\textend(road, superClass);\n\n\t\tfunction road(pos, hitCheaker) {\n\t\t\tthis._lifeUpEffectLing = bind(this._lifeUpEffectLing, this);\n\t\t\tthis._eCompleteMaxCombo = bind(this._eCompleteMaxCombo, this);\n\t\t\tthis.disposeGround = bind(this.disposeGround, this);\n\t\t\tthis.disposeStgparts = bind(this.disposeStgparts, this);\n\t\t\tthis.disposeItems = bind(this.disposeItems, this);\n\t\t\tthis.disposeRoad = bind(this.disposeRoad, this);\n\t\t\tthis._hideAllItem = bind(this._hideAllItem, this);\n\t\t\tthis._hitTestItems = bind(this._hitTestItems, this);\n\t\t\tthis._eClick = bind(this._eClick, this);\n\t\t\tthis._updateLookOffset = bind(this._updateLookOffset, this);\n\t\t\tthis.mesh = bind(this.mesh, this);\n\t\t\tthis.dispose = bind(this.dispose, this);\n\t\t\tthis._getUseItem = bind(this._getUseItem, this);\n\t\t\tthis._eAddItemAtRoad = bind(this._eAddItemAtRoad, this);\n\t\t\tthis._initRoadParam = bind(this._initRoadParam, this);\n\t\t\tthis._enterNextStage = bind(this._enterNextStage, this);\n\t\t\tthis._setUpNextStage = bind(this._setUpNextStage, this);\n\t\t\tthis._endStage = bind(this._endStage, this);\n\t\t\tthis._hideEtcStage = bind(this._hideEtcStage, this);\n\t\t\tthis.usableGame = bind(this.usableGame, this);\n\t\t\tthis._offsetLoadAtY = bind(this._offsetLoadAtY, this);\n\t\t\tthis._offsetLoadAtX = bind(this._offsetLoadAtX, this);\n\t\t\tthis._getLoadAtPos = bind(this._getLoadAtPos, this);\n\t\t\tthis._checkSeaState = bind(this._checkSeaState, this);\n\t\t\tthis.update = bind(this.update, this);\n\t\t\tthis._setPositionAtRoad = bind(this._setPositionAtRoad, this);\n\t\t\tthis._computeNextStageAt = bind(this._computeNextStageAt, this);\n\t\t\tthis._computeLoopStartAt = bind(this._computeLoopStartAt, this);\n\t\t\tthis.reset = bind(this.reset, this);\n\t\t\tthis._makeRing = bind(this._makeRing, this);\n\t\t\tthis._makeItemRankTable = bind(this._makeItemRankTable, this);\n\t\t\tthis._makeItems = bind(this._makeItems, this);\n\t\t\tthis._hideRing = bind(this._hideRing, this);\n\t\t\tthis._setRing = bind(this._setRing, this);\n\t\t\tthis._setStgparts = bind(this._setStgparts, this);\n\t\t\tthis._hideStgparts = bind(this._hideStgparts, this);\n\t\t\tthis._makeStgparts = bind(this._makeStgparts, this);\n\t\t\tthis._addGround = bind(this._addGround, this);\n\t\t\tthis._getDepthGeometry = bind(this._getDepthGeometry, this);\n\t\t\tthis._switchRoad = bind(this._switchRoad, this);\n\t\t\tthis.makeRoad = bind(this.makeRoad, this);\n\t\t\tthis._getAtFromX2 = bind(this._getAtFromX2, this);\n\t\t\tthis._getAtFromX = bind(this._getAtFromX, this);\n\t\t\tthis._getAtFromZ = bind(this._getAtFromZ, this);\n\t\t\tthis._makeRoadGeometryFromSplinePoints = bind(this._makeRoadGeometryFromSplinePoints, this);\n\t\t\tthis._addLoopAreaSplinePoints = bind(this._addLoopAreaSplinePoints, this);\n\t\t\tthis._makeGameAreaSplinePoints = bind(this._makeGameAreaSplinePoints, this);\n\t\t\tthis.goNextStage = bind(this.goNextStage, this);\n\t\t\tthis.isDraw = bind(this.isDraw, this);\n\t\t\tthis.stopRun = bind(this.stopRun, this);\n\t\t\tthis.startRun = bind(this.startRun, this);\n\t\t\tthis.start = bind(this.start, this);\n\t\t\troad.__super__.constructor.call(this);\n\t\t\tthis._geo;\n\t\t\tthis._mesh;\n\t\t\tthis._nextGeo;\n\t\t\tthis._nextMesh;\n\t\t\tthis._binormal = new THREE.Vector3();\n\t\t\tthis._normal = new THREE.Vector3();\n\t\t\tthis._cameraRot;\n\t\t\tthis._mat;\n\t\t\tthis._maxAt = 0;\n\t\t\tthis._lookOffset = {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0\n\t\t\t};\n\t\t\tthis._at = 0;\n\t\t\tthis._bufAt = 0;\n\t\t\tthis._atP = 0;\n\t\t\tthis._runSpeed = 0;\n\t\t\tthis._runSpeedTg = 0;\n\t\t\tthis._loopStartAt = 0;\n\t\t\tthis._nextStageAt = 0;\n\t\t\tthis._loopCnt = 0;\n\t\t\tthis._baseFloor = 0;\n\t\t\tthis._baseFloorTg = 0;\n\t\t\tthis._sky;\n\t\t\tthis._sea;\n\t\t\tthis._line;\n\t\t\tthis._comboMaxEffect;\n\t\t\tthis._showItemMgr;\n\t\t\tthis._ring = [];\n\t\t\tthis._items = [];\n\t\t\tthis._stgparts = [];\n\t\t\tthis._ground = [];\n\t\t\tthis._nowGround;\n\t\t\tthis._hitRay;\n\t\t\tthis._isInSea = false;\n\t\t\tthis._inSeaAt = 0;\n\t\t\tthis._outSeaAt = 0;\n\t\t\tthis._isPlaying = false;\n\t\t\tthis._isMakeRoad = false;\n\t\t\tthis._isDraw = true;\n\t\t\tthis._isPlayingGame = false;\n\t\t\tthis._isShowItem = false;\n\t\t\tthis._isEnterLoopArea = false;\n\t\t\tthis.onGetItem;\n\t\t\tthis.onEndStage;\n\t\t\tthis.onEnterLoopArea;\n\t\t\tthis.onSetupNextStage;\n\t\t\tthis.onEnterNextStage;\n\t\t\tthis.onStartNextStage;\n\t\t}\n\n\t\troad.prototype.start = function() {\n\t\t\tvar roadTex;\n\t\t\troad.__super__.start.call(this);\n\t\t\tthis._cameraRot = this._camera.rotation.clone();\n\t\t\tthis._hitRay = new THREE.Raycaster();\n\t\t\tthis._interaction.addOnClick(this._eClick);\n\t\t\troadTex = THREE.ImageUtils.loadTexture(this._conf.PATH_IMG.TEX + \"niji.jpg\");\n\t\t\tthis._mat = new THREE.MeshBasicMaterial({\n\t\t\t\tmap: roadTex\n\t\t\t});\n\t\t\tthis._sky = new root.MY_CLASS.sky();\n\t\t\tthis._sky.start();\n\t\t\tthis._sea = new root.MY_CLASS.sea();\n\t\t\tthis._sea.start();\n\t\t\tthis._line = new root.MY_CLASS.line();\n\t\t\tthis._line.start();\n\t\t\tthis._line.show();\n\t\t\tthis._line.onCompleteMaxCombo = this._eCompleteMaxCombo;\n\t\t\tthis._comboMaxEffect = new root.MY_CLASS.comboMax();\n\t\t\tthis._comboMaxEffect.start();\n\t\t\tthis._makeItems();\n\t\t\tif (!this._conf.IS_CAP) {\n\t\t\t\tthis._makeRing();\n\t\t\t}\n\t\t\tthis._showItemMgr = new root.MY_CLASS.showItemMgr(this._items);\n\t\t\tthis._showItemMgr.onShowItem = this._eAddItemAtRoad;\n\t\t\tthis._showItemMgr.start();\n\t\t\treturn this._isPlaying = true;\n\t\t};\n\n\t\troad.prototype.startRun = function() {\n\t\t\tthis._isPlaying = true;\n\t\t\tthis._isPlayingGame = true;\n\t\t\tthis._isShowItem = false;\n\t\t\tthis._baseFloor = this._conf.BASE_FLOOR;\n\t\t\tthis._sky.show();\n\t\t\tthis._sea.hide();\n\t\t\tthis._initRoadParam();\n\t\t\tthis._camera.rotation.z = this._cameraRot.z = 1.5707963267948966 + this._u.radian(0);\n\t\t\treturn this._cameraRot = this._camera.rotation.clone();\n\t\t};\n\n\t\troad.prototype.stopRun = function() {\n\t\t\tthis._isPlaying = false;\n\t\t\treturn this.update();\n\t\t};\n\n\t\troad.prototype.isDraw = function(bool) {\n\t\t\tvar ground;\n\t\t\tthis._isDraw = bool;\n\t\t\tthis.update();\n\t\t\tif (bool) {\n\t\t\t\tthis._container.visible = true;\n\t\t\t\tthis._sky.show();\n\t\t\t} else {\n\t\t\t\tthis._container.visible = false;\n\t\t\t\tthis._sky.hide();\n\t\t\t}\n\t\t\tground = this._ground[this._game.stageId()];\n\t\t\tif (ground != null) {\n\t\t\t\treturn ground.update();\n\t\t\t}\n\t\t};\n\n\t\troad.prototype.goNextStage = function() {\n\t\t\treturn this.makeRoad(true);\n\t\t};\n\n\t\troad.prototype._makeGameAreaSplinePoints = function(stageId) {\n\t\t\tvar arr, i, j, key, len1, p, val;\n\t\t\tswitch (stageId) {\n\t\t\t\tcase 4:\n\t\t\t\t\tp = this._conf.ROAD_POINT[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tp = this._conf.ROAD_POINT[1];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tp = this._conf.ROAD_POINT[2];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tkey = this._u.random(3, 6);\n\t\t\t\t\tp = this._conf.ROAD_POINT[key];\n\t\t\t}\n\t\t\tarr = [];\n\t\t\tfor (i = j = 0, len1 = p.length; j < len1; i = ++j) {\n\t\t\t\tval = p[i];\n\t\t\t\tarr.push(new THREE.Vector3(val.x, val.y, val.z));\n\t\t\t}\n\t\t\treturn arr;\n\t\t};\n\n\t\troad.prototype._addLoopAreaSplinePoints = function(stageId, points) {\n\t\t\tvar addZ, i, last, len, results, x, y, z;\n\t\t\tlast = points[points.length - 1];\n\t\t\tx = last.x;\n\t\t\ty = last.y;\n\t\t\tz = last.z;\n\t\t\taddZ = this._conf.GAME_SPEED[this._game.stageId()];\n\t\t\ti = 0;\n\t\t\tlen = this._conf.ROAD_SPLINE_POINT_NUM[this._game.stageId()] - points.length;\n\t\t\tresults = [];\n\t\t\twhile (i < len) {\n\t\t\t\tswitch (stageId) {\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tif (i < 8) {\n\t\t\t\t\t\t\tz -= addZ * 0.5;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tz -= addZ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx = this._conf.STG5_OFFSET_Y;\n\t\t\t\t\t\ty = this._conf.LOOP_PT.Y;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tif (i < 16) {\n\t\t\t\t\t\t\tz -= addZ * 0.5;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tz -= addZ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx = this._conf.LOOP_PT.X;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tz -= addZ;\n\t\t\t\t\t\tx += (this._conf.LOOP_PT.Y - x) * 0.3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tz -= addZ;\n\t\t\t\t\t\tx = this._conf.LOOP_PT.X;\n\t\t\t\t\t\ty = this._conf.LOOP_PT.Y;\n\t\t\t\t}\n\t\t\t\tpoints.push(new THREE.Vector3(x, y, z));\n\t\t\t\tresults.push(i++);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t\troad.prototype._makeRoadGeometryFromSplinePoints = function(points) {\n\t\t\tvar geo, radSegments, radius, segments, spline;\n\t\t\tsegments = 5000;\n\t\t\tradius = 10;\n\t\t\tradSegments = 2;\n\t\t\tspline = new THREE.SplineCurve3(points);\n\t\t\tgeo = new THREE.TubeGeometry(spline, segments, radius, radSegments, false);\n\t\t\tgeo.computeBoundingSphere();\n\t\t\tgeo.computeBoundingBox();\n\t\t\treturn geo;\n\t\t};\n\n\t\troad.prototype._getAtFromZ = function(z, useGeometry, useMesh) {\n\t\t\tvar add, pos, t;\n\t\t\tpos = new THREE.Vector3();\n\t\t\tt = 0;\n\t\t\tadd = this._conf.ROAD_ANALYZE_P;\n\t\t\twhile (t < 1) {\n\t\t\t\tpos = useGeometry.parameters.path.getPointAt(t);\n\t\t\t\tif (pos.z <= z) {\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t\tt += add;\n\t\t\t}\n\t\t\treturn 1;\n\t\t};\n\n\t\troad.prototype._getAtFromX = function(x, useGeometry) {\n\t\t\tvar add, pos, t;\n\t\t\tt = 0;\n\t\t\tadd = this._conf.ROAD_ANALYZE_P;\n\t\t\twhile (t < 1) {\n\t\t\t\tpos = useGeometry.parameters.path.getPointAt(t);\n\t\t\t\tif (pos.x >= x) {\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t\tt += add;\n\t\t\t}\n\t\t\treturn 1;\n\t\t};\n\n\t\troad.prototype._getAtFromX2 = function(x, useGeometry) {\n\t\t\tvar add, pos, t;\n\t\t\tt = 0;\n\t\t\tadd = this._conf.ROAD_ANALYZE_P;\n\t\t\twhile (t < 1) {\n\t\t\t\tpos = useGeometry.parameters.path.getPointAt(t);\n\t\t\t\tif (pos.x <= x) {\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t\tt += add;\n\t\t\t}\n\t\t\treturn 1;\n\t\t};\n\n\t\troad.prototype.makeRoad = function(isNext) {\n\t\t\tvar dd, gameAreaGeometry, gameAreaSize, gameAreaSize2, gameAreaStgSize, i, last, lastZ, maxAt, mesh, needRoadSize, num, offsetZ, roadGeo, roadPoints, totalStgSize;\n\t\t\tif (isNext == null) {\n\t\t\t\tisNext = false;\n\t\t\t}\n\t\t\troadPoints = this._makeGameAreaSplinePoints(this._game.stageId());\n\t\t\tgameAreaGeometry = this._makeRoadGeometryFromSplinePoints(roadPoints);\n\t\t\tgameAreaSize = this._getDepthGeometry(gameAreaGeometry);\n\t\t\tgameAreaGeometry.dispose();\n\t\t\tswitch (this._game.stageId()) {\n\t\t\t\tcase 4:\n\t\t\t\t\tgameAreaSize2 = gameAreaSize - this._conf.GAME_END_OFFSET[this._game.stageId()];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tgameAreaSize2 = gameAreaSize;\n\t\t\t}\n\t\t\tthis._addGround(gameAreaSize2);\n\t\t\tgameAreaStgSize = this._ground[this._game.stageId()].gameAreaSize();\n\t\t\ttotalStgSize = this._ground[this._game.stageId()].totalSize();\n\t\t\tneedRoadSize = totalStgSize - gameAreaSize;\n\t\t\toffsetZ = -1000;\n\t\t\tlast = roadPoints[roadPoints.length - 1];\n\t\t\tlastZ = last.z - needRoadSize + offsetZ;\n\t\t\ti = 1;\n\t\t\tdd = 380;\n\t\t\tif (this._game.stageId() === 4) {\n\t\t\t\tdd = 450;\n\t\t\t}\n\t\t\tif (this._game.stageId() === 5) {\n\t\t\t\tdd = 450;\n\t\t\t}\n\t\t\tif (this._game.stageId() === 6) {\n\t\t\t\tdd = 850;\n\t\t\t}\n\t\t\tnum = ~~(needRoadSize / dd) + 1;\n\t\t\twhile (i <= num) {\n\t\t\t\troadPoints.push(new THREE.Vector3(last.x, last.y, last.z + i * ((lastZ - last.z) / num)));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\troadGeo = this._makeRoadGeometryFromSplinePoints(roadPoints);\n\t\t\tmesh = new THREE.Mesh(roadGeo, this._mat);\n\t\t\tthis._container.add(mesh);\n\t\t\tif (isNext) {\n\t\t\t\tthis._nextGeo = roadGeo;\n\t\t\t\tthis._nextMesh = mesh;\n\t\t\t} else {\n\t\t\t\tthis._geo = roadGeo;\n\t\t\t\tthis._mesh = mesh;\n\t\t\t}\n\t\t\tmaxAt = this._getAtFromZ(this._ground[this._game.stageId()].gameAreaEndZ(), this._nextGeo || this._geo, this._nextMesh || this._mesh);\n\t\t\tthis._setStgparts(maxAt);\n\t\t\treturn this._isMakeRoad = true;\n\t\t};\n\n\t\troad.prototype._switchRoad = function() {\n\t\t\tif (this._mesh != null) {\n\t\t\t\tthis._container.remove(this._mesh);\n\t\t\t\tthis._mesh = null;\n\t\t\t\tthis._geo.dispose();\n\t\t\t\tthis._geo = null;\n\t\t\t}\n\t\t\tthis._geo = this._nextGeo;\n\t\t\tthis._mesh = this._nextMesh;\n\t\t\tthis._nextGeo = null;\n\t\t\treturn this._nextMesh = null;\n\t\t};\n\n\t\troad.prototype._getDepthGeometry = function(geometry) {\n\t\t\treturn this.depthFromBBox(geometry.boundingBox);\n\t\t};\n\n\t\troad.prototype._addGround = function(gameAreaSize) {\n\t\t\tvar ground;\n\t\t\tif (this._ground[this._game.stageId()] != null) {\n\t\t\t\tground = this._ground[this._game.stageId()];\n\t\t\t\tground.container().position.z = 0;\n\t\t\t\tground.container().visible = true;\n\t\t\t\tground.show();\n\t\t\t} else {\n\t\t\t\tground = new root.MY_CLASS.ground(gameAreaSize);\n\t\t\t\tground.start();\n\t\t\t\tground.show();\n\t\t\t}\n\t\t\tif (this._nowGround == null) {\n\t\t\t\tthis._nowGround = ground;\n\t\t\t}\n\t\t\treturn this._ground[this._game.stageId()] = ground;\n\t\t};\n\n\t\troad.prototype._makeStgparts = function() {};\n\n\t\troad.prototype._hideStgparts = function() {};\n\n\t\troad.prototype._setStgparts = function(maxAt) {};\n\n\t\troad.prototype._setRing = function() {\n\t\t\tvar i, num, pos, results, ring, t;\n\t\t\tnum = this._ring.length;\n\t\t\ti = 0;\n\t\t\tresults = [];\n\t\t\twhile (i < num) {\n\t\t\t\tt = (i / num) * this._maxAt;\n\t\t\t\tpos = this._getLoadAtPos(t, 0);\n\t\t\t\tthis._offsetLoadAtY(pos, 10);\n\t\t\t\tring = this._ring[i];\n\t\t\t\tring.show(pos);\n\t\t\t\tresults.push(i++);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t\troad.prototype._hideRing = function() {\n\t\t\tvar i, j, len1, ref, results, val;\n\t\t\tref = this._ring;\n\t\t\tresults = [];\n\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\tval = ref[i];\n\t\t\t\tresults.push(val.hide());\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t\troad.prototype._makeItems = function() {\n\t\t\tvar i, item, len, rankTable, results;\n\t\t\trankTable = this._makeItemRankTable();\n\t\t\ti = 0;\n\t\t\tlen = this._conf.PRE_SET_ITEM_NUM;\n\t\t\tresults = [];\n\t\t\twhile (i < len) {\n\t\t\t\titem = new root.MY_CLASS.item(rankTable[i] || 0);\n\t\t\t\titem.start();\n\t\t\t\tthis._items.push(item);\n\t\t\t\tresults.push(i++);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t\troad.prototype._makeItemRankTable = function() {\n\t\t\tvar i, j, k, l, len1, len2, nums, ref, table, val;\n\t\t\ttable = [];\n\t\t\tnums = [];\n\t\t\tref = this._conf.ITEM_RANK_RATE;\n\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\tval = ref[i];\n\t\t\t\tnums[i] = ~~(val * this._conf.PRE_SET_ITEM_NUM);\n\t\t\t}\n\t\t\tfor (i = k = 0, len2 = nums.length; k < len2; i = ++k) {\n\t\t\t\tval = nums[i];\n\t\t\t\tl = 0;\n\t\t\t\twhile (l < val) {\n\t\t\t\t\ttable.push(i);\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn table;\n\t\t};\n\n\t\troad.prototype._makeRing = function() {\n\t\t\tvar i, len, results, ring;\n\t\t\ti = 0;\n\t\t\tlen = this._conf.PRE_SET_RING_NUM;\n\t\t\tresults = [];\n\t\t\twhile (i < len) {\n\t\t\t\tring = new root.MY_CLASS.ring(i);\n\t\t\t\tring.start();\n\t\t\t\tthis._ring.push(ring);\n\t\t\t\tresults.push(i++);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t\troad.prototype.reset = function() {\n\t\t\tvar ground;\n\t\t\troad.__super__.reset.call(this);\n\t\t\tthis._isPlaying = false;\n\t\t\tthis._isMakeRoad = false;\n\t\t\tthis._isPlayingGame = false;\n\t\t\tthis._isShowItem = true;\n\t\t\tthis._at = 0;\n\t\t\tthis._hideStgparts();\n\t\t\tthis._hideAllItem();\n\t\t\tthis._hideRing();\n\t\t\tthis._hideEtcStage();\n\t\t\tthis._nowGround = null;\n\t\t\tthis.disposeRoad();\n\t\t\tthis._line.reset();\n\t\t\tground = this._ground[this._game.stageId()];\n\t\t\tif (ground != null) {\n\t\t\t\tground.container().position.z = 0;\n\t\t\t\treturn ground.container().visible = true;\n\t\t\t}\n\t\t};\n\n\t\troad.prototype._computeLoopStartAt = function() {\n\t\t\tvar add, pos, t;\n\t\t\tpos = new THREE.Vector3();\n\t\t\tt = this._maxAt;\n\t\t\tadd = this._conf.ROAD_ANALYZE_P;\n\t\t\twhile (t < 1) {\n\t\t\t\tpos = this._geo.parameters.path.getPointAt(t);\n\t\t\t\tif (pos.z <= this._nowGround.container().position.z + this._nowGround.loopStartZ()) {\n\t\t\t\t\tthis._loopStartAt = t;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tt += add;\n\t\t\t}\n\t\t\treturn this._loopStartAt = t;\n\t\t};\n\n\t\troad.prototype._computeNextStageAt = function() {\n\t\t\tvar add, maxZ, pos, t;\n\t\t\tpos = new THREE.Vector3();\n\t\t\tmaxZ = -this._nowGround.totalSize();\n\t\t\tt = this._loopStartAt;\n\t\t\tadd = this._conf.ROAD_ANALYZE_P;\n\t\t\twhile (t < 1) {\n\t\t\t\tpos = this._geo.parameters.path.getPointAt(t);\n\t\t\t\tif (pos.z <= maxZ) {\n\t\t\t\t\tthis._nextStageAt = t;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tt += add;\n\t\t\t}\n\t\t\treturn this._nextStageAt = t;\n\t\t};\n\n\t\troad.prototype._setPositionAtRoad = function(at, position, useGeometry, useMesh) {\n\t\t\tvar dir, pick, pickNext, pickt, pos, segments;\n\t\t\tpos = useGeometry.parameters.path.getPointAt(at);\n\t\t\tsegments = useGeometry.tangents.length;\n\t\t\tpickt = at * segments;\n\t\t\tpick = Math.floor(pickt);\n\t\t\tpickNext = (pick + 1) % segments;\n\t\t\tif ((useGeometry.binormals[pickNext] != null) && (useGeometry.binormals[pick] != null)) {\n\t\t\t\tthis._binormal.subVectors(useGeometry.binormals[pickNext], useGeometry.binormals[pick]);\n\t\t\t\tthis._binormal.multiplyScalar(pickt - pick).add(useGeometry.binormals[pick]);\n\t\t\t}\n\t\t\tdir = useGeometry.parameters.path.getTangentAt(at);\n\t\t\tthis._normal.copy(this._binormal).cross(dir);\n\t\t\tpos.add(this._binormal.clone().multiplyScalar(this._baseFloor));\n\t\t\tposition.copy(pos);\n\t\t\treturn position.z += useMesh.position.z;\n\t\t};\n\n\t\troad.prototype.update = function() {\n\t\t\tvar ease, eyeDist, lookAt, newAt, now, nowSpeed, speedEase, tg0, tg1;\n\t\t\troad.__super__.update.call(this);\n\t\t\tif (!this._isDraw) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._baseFloorTg = this._conf.BASE_FLOOR;\n\t\t\tthis._updateLookOffset();\n\t\t\tthis._hitTestItems(this._interaction.mouse().x, this._interaction.mouse().y);\n\t\t\tif (this._isPlaying) {\n\t\t\t\tif (this.usableGame()) {\n\t\t\t\t\tnewAt = this._audio.stgBgmRate() * this._maxAt;\n\t\t\t\t\tnowSpeed = newAt - this._bufAt;\n\t\t\t\t\tthis._bufAt = newAt;\n\t\t\t\t\tspeedEase = this._game.clearStageNum() > 0 && this._at < 0.1 ? 0.01 : 0.75;\n\t\t\t\t\tthis._runSpeed += (nowSpeed - this._runSpeed) * speedEase;\n\t\t\t\t\ttg0 = this._at + this._runSpeed;\n\t\t\t\t\ttg1 = this._bufAt;\n\t\t\t\t\tthis._atP = Math.min(this._atP += 0.000002, 1);\n\t\t\t\t\tthis._at = tg0 * (1 - this._atP) + tg1 * this._atP;\n\t\t\t\t\tif (this._game.clearStageNum() === 0 && this._bufAt > 0.008) {\n\t\t\t\t\t\tthis._isShowItem = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!this._isShowItem && this._bufAt > this._conf.GAME_START_LOAD_AT[this._game.stageId()]) {\n\t\t\t\t\t\t\tthis._isShowItem = true;\n\t\t\t\t\t\t\tif (this.onStartNextStage != null) {\n\t\t\t\t\t\t\t\tthis.onStartNextStage();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._at = Math.min(1, this._at += this._runSpeed);\n\t\t\t\t\tif (this._game.stageId() === 4 || this._game.stageId() === 5) {\n\t\t\t\t\t\tif (this._isEnterLoopArea) {\n\t\t\t\t\t\t\tthis._runSpeed += (this._runSpeedTg - this._runSpeed) * 0.02;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._runSpeed += (this._runSpeedTg - this._runSpeed) * 0.002;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._runSpeed += (this._runSpeedTg - this._runSpeed) * 0.02;\n\t\t\t\t\t}\n\t\t\t\t\tthis._baseFloorTg = this._conf.BASE_FLOOR + 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._at = this._at;\n\t\t\t}\n\t\t\tthis._baseFloor += (this._baseFloorTg - this._baseFloor) * 0.05;\n\t\t\tthis._setPositionAtRoad(this._at, this._camera.position, this._geo, this._mesh);\n\t\t\tif (!this.usableGame()) {\n\t\t\t\tthis._endStage();\n\t\t\t\tif (this._isMakeRoad && this._loopCnt > 0) {\n\t\t\t\t\tif (this._nextStageAt <= this._at || this._at >= 1) {\n\t\t\t\t\t\tthis._enterNextStage();\n\t\t\t\t\t\tthis._setPositionAtRoad(this._at, this._camera.position, this._geo, this._mesh);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!this._isEnterLoopArea && this._camera.position.z < this._nowGround.container().position.z + this._nowGround.loopGroundStartZ()) {\n\t\t\t\t\t\tthis._isEnterLoopArea = true;\n\t\t\t\t\t\tthis._hideStgparts();\n\t\t\t\t\t\tif (this.onEnterLoopArea != null) {\n\t\t\t\t\t\t\tthis.onEnterLoopArea();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this._camera.position.z < (this._nowGround.container().position.z + this._nowGround.loopStartZ()) - this._nowGround.loopZ()) {\n\t\t\t\t\t\tthis._loopCnt++;\n\t\t\t\t\t\tthis._nowGround.container().position.z = this._mesh.position.z = this._nowGround.totalSize();\n\t\t\t\t\t\tthis._at -= this._at - this._loopStartAt;\n\t\t\t\t\t\tthis._setPositionAtRoad(this._at, this._camera.position, this._geo, this._mesh);\n\t\t\t\t\t\tif (this._loopCnt === 1) {\n\t\t\t\t\t\t\tthis._setUpNextStage();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teyeDist = this._conf.LOOK_AT_ROAD;\n\t\t\tnow = (this._at + eyeDist / this._geo.parameters.path.getLength()) % 1;\n\t\t\tlookAt = this._geo.parameters.path.getPointAt(now);\n\t\t\tlookAt.z += this._mesh.position.z;\n\t\t\tif (this._isShowItem && this.usableGame()) {\n\t\t\t\tif (this._showItemMgr.showItem(this._at)) {\n\t\t\t\t\tthis._u.shuffle(this._items);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlookAt.add(this._binormal.clone().multiplyScalar(this._baseFloor + this._lookOffset.y));\n\t\t\tlookAt.add(this._normal.clone().multiplyScalar(this._lookOffset.x));\n\t\t\tthis._camera.matrix.lookAt(this._camera.position, lookAt, this._binormal);\n\t\t\tthis._cameraRot.setFromRotationMatrix(this._camera.matrix, this._camera.rotation.order);\n\t\t\tease = this._at < 0.005 && this._game.clearStageNum() > 0 ? 0.001 : 0.2;\n\t\t\tthis._camera.rotation.x += (this._cameraRot.x - this._camera.rotation.x) * ease;\n\t\t\tthis._camera.rotation.y += (this._cameraRot.y - this._camera.rotation.y) * ease;\n\t\t\tthis._camera.rotation.z += (this._cameraRot.z - this._camera.rotation.z) * ease;\n\t\t\tthis._checkSeaState(this._at);\n\t\t\tif (this._game.stageId() === 6 && this._bufAt >= 0.28 && (this._nowGround != null)) {\n\t\t\t\treturn this._nowGround.openDoor();\n\t\t\t}\n\t\t};\n\n\t\troad.prototype._checkSeaState = function(t) {\n\t\t\tif (this._inSeaAt !== -1 && !this._sea.container().visible && t >= this._inSeaAt) {\n\t\t\t\tthis._sky.hide();\n\t\t\t\tthis._sea.show();\n\t\t\t\tthis._audio.playSeaDownSe();\n\t\t\t}\n\t\t\tif (this._outSeaAt !== -1 && !this._sky.container().visible && t >= this._outSeaAt) {\n\t\t\t\tthis._sky.show();\n\t\t\t\tthis._sea.hide();\n\t\t\t\treturn this._audio.playSeaUpSe();\n\t\t\t}\n\t\t};\n\n\t\troad.prototype._getLoadAtPos = function(t, offset) {\n\t\t\tvar at, dir, geo, pick, pickNext, pickt, segments;\n\t\t\tif (this._nextGeo != null) {\n\t\t\t\tgeo = this._nextGeo;\n\t\t\t} else {\n\t\t\t\tgeo = this._geo;\n\t\t\t}\n\t\t\tat = (t + offset / geo.parameters.path.getLength()) % 1;\n\t\t\tsegments = geo.tangents.length;\n\t\t\tpickt = t * segments;\n\t\t\tpick = Math.floor(pickt);\n\t\t\tpickNext = (pick + 1) % segments;\n\t\t\tif ((geo.binormals[pickNext] != null) && (geo.binormals[pick] != null)) {\n\t\t\t\tthis._binormal.subVectors(geo.binormals[pickNext], geo.binormals[pick]);\n\t\t\t\tthis._binormal.multiplyScalar(pickt - pick).add(geo.binormals[pick]);\n\t\t\t}\n\t\t\tdir = geo.parameters.path.getTangentAt(t);\n\t\t\tthis._normal.copy(this._binormal).cross(dir);\n\t\t\treturn geo.parameters.path.getPointAt(at);\n\t\t};\n\n\t\troad.prototype._offsetLoadAtX = function(pos, offset) {\n\t\t\treturn pos.add(this._normal.clone().multiplyScalar(offset));\n\t\t};\n\n\t\troad.prototype._offsetLoadAtY = function(pos, offset) {\n\t\t\treturn pos.add(this._binormal.clone().multiplyScalar(offset));\n\t\t};\n\n\t\troad.prototype.usableGame = function() {\n\t\t\tif (this._at > this._bufAt) {\n\t\t\t\treturn this._at < this._maxAt;\n\t\t\t} else {\n\t\t\t\treturn this._bufAt < this._maxAt;\n\t\t\t}\n\t\t};\n\n\t\troad.prototype._hideEtcStage = function() {\n\t\t\tvar i, j, len1, ref, results, val;\n\t\t\tref = this._ground;\n\t\t\tresults = [];\n\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\tval = ref[i];\n\t\t\t\tif ((val != null) && i !== this._game.stageId()) {\n\t\t\t\t\tval.container().position.z = 0;\n\t\t\t\t\tresults.push(val.hide());\n\t\t\t\t} else {\n\t\t\t\t\tresults.push(void 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t\troad.prototype._endStage = function() {\n\t\t\tif (this._isPlayingGame && this._isMakeRoad) {\n\t\t\t\tthis._isPlayingGame = false;\n\t\t\t\tthis._isMakeRoad = false;\n\t\t\t\tthis._computeLoopStartAt();\n\t\t\t\tthis._computeNextStageAt();\n\t\t\t\tthis._hideRing();\n\t\t\t\tif (this.onEndStage != null) {\n\t\t\t\t\treturn this.onEndStage();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\troad.prototype._setUpNextStage = function() {\n\t\t\tif (this.onSetupNextStage != null) {\n\t\t\t\treturn this.onSetupNextStage();\n\t\t\t}\n\t\t};\n\n\t\troad.prototype._enterNextStage = function() {\n\t\t\tthis._switchRoad();\n\t\t\tthis._nowGround = this._ground[this._game.stageId()];\n\t\t\tthis._isPlayingGame = true;\n\t\t\tthis._isShowItem = false;\n\t\t\tthis._hideEtcStage();\n\t\t\tthis._hideAllItem();\n\t\t\tthis._initRoadParam();\n\t\t\tthis._sky.setSky(this._game.stageId(), true);\n\t\t\tif (this.onEnterNextStage != null) {\n\t\t\t\treturn this.onEnterNextStage();\n\t\t\t}\n\t\t};\n\n\t\troad.prototype._initRoadParam = function() {\n\t\t\tthis._at = 0;\n\t\t\tthis._bufAt = 0;\n\t\t\tthis._atP = 0;\n\t\t\tthis._loopStartAt = 0;\n\t\t\tthis._loopCnt = 0;\n\t\t\tthis._isEnterLoopArea = false;\n\t\t\tthis._runSpeedTg = this._conf.LOOP_AREA_SPEED[this._game.stageId()];\n\t\t\tthis._inSeaAt = -1;\n\t\t\tthis._outSeaAt = -1;\n\t\t\tif (this._game.stageId() === 4) {\n\t\t\t\tthis._inSeaAt = this._getAtFromX(-this._conf.GROUND_OFFSET.Y, this._geo);\n\t\t\t} else if (this._game.stageId() === 5) {\n\t\t\t\tthis._outSeaAt = this._getAtFromX2(-this._conf.GROUND_OFFSET.Y + 100, this._geo);\n\t\t\t}\n\t\t\tswitch (this._game.stageId()) {\n\t\t\t\tcase 4:\n\t\t\t\t\tthis._maxAt = this._getAtFromZ(-this._nowGround.minGameAreaSize() + this._conf.GAME_END_OFFSET[this._game.stageId()], this._geo, this._mesh);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tthis._maxAt = this._getAtFromZ(-this._nowGround.minGameAreaSize() + this._conf.GAME_END_OFFSET[this._game.stageId()], this._geo, this._mesh);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tthis._maxAt = this._getAtFromZ(-this._nowGround.minGameAreaSize() + this._conf.GAME_END_OFFSET[this._game.stageId()], this._geo, this._mesh);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis._maxAt = this._getAtFromZ(this._nowGround.gameAreaEndZ() + this._conf.GAME_END_OFFSET[this._game.stageId()], this._geo, this._mesh);\n\t\t\t}\n\t\t\treturn this._setRing();\n\t\t};\n\n\t\troad.prototype._eAddItemAtRoad = function(at, offsetX, offsetY, order, interval, zOffset) {\n\t\t\tvar itemAt, itemPos, rank, useItem, z, zRange;\n\t\t\tuseItem = this._getUseItem();\n\t\t\tif (useItem == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trank = useItem.rank();\n\t\t\tzRange = this._conf.SHOW_ITEM_Z[this._game.stageId()];\n\t\t\tz = this._u.random(zRange[0], zRange[1]) + zOffset;\n\t\t\tif (this._isSmt && Math.abs(window.orientation) === 90) {\n\t\t\t\tz *= 0.9;\n\t\t\t}\n\t\t\titemAt = (at + z / this._geo.parameters.path.getLength()) % 1;\n\t\t\titemPos = this._geo.parameters.path.getPointAt(itemAt);\n\t\t\titemPos.add(this._binormal.clone().multiplyScalar(this._baseFloor + offsetY));\n\t\t\titemPos.add(this._normal.clone().multiplyScalar(offsetX));\n\t\t\tuseItem.show(itemPos, order, interval);\n\t\t\treturn useItem;\n\t\t};\n\n\t\troad.prototype._getUseItem = function() {\n\t\t\tvar i, j, len1, ref, val;\n\t\t\tref = this._items;\n\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\tval = ref[i];\n\t\t\t\tif (!val.isContainStage()) {\n\t\t\t\t\treturn val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\n\t\troad.prototype.dispose = function() {\n\t\t\treturn road.__super__.dispose.call(this);\n\t\t};\n\n\t\troad.prototype.mesh = function() {\n\t\t\treturn this._mesh;\n\t\t};\n\n\t\troad.prototype._updateLookOffset = function() {\n\t\t\tvar ease, nm, rangeX, rangeY, tx, ty;\n\t\t\tif (root.MY.myfw.conf.IS_SMT) {\n\t\t\t\tease = this._parameter.get(\"moveSpeed\");\n\t\t\t\tnm = this._interaction.getNormalizeDeviceAng();\n\t\t\t\trangeX = this._parameter.get(\"moveX\");\n\t\t\t\trangeY = this._parameter.get(\"moveY\");\n\t\t\t\ttx = this._u.map(nm.x, rangeX, -rangeX, 0, 1);\n\t\t\t\tty = this._u.map(nm.y, -rangeY, rangeY, 0, 1);\n\t\t\t} else {\n\t\t\t\tease = this._parameter.get(\"moveSpeed\");\n\t\t\t\tnm = this._interaction.getNormalizeMousePos();\n\t\t\t\trangeX = this._parameter.get(\"moveX\");\n\t\t\t\trangeY = this._parameter.get(\"moveY\");\n\t\t\t\ttx = this._u.map(nm.x, rangeX, -rangeX, 0, 1);\n\t\t\t\tty = this._u.map(nm.y, rangeY, -rangeY, 0, 1);\n\t\t\t}\n\t\t\tthis._lookOffset.x += (tx - this._lookOffset.x) * ease;\n\t\t\treturn this._lookOffset.y += (ty - this._lookOffset.y) * ease;\n\t\t};\n\n\t\troad.prototype._eClick = function(mouse) {\n\t\t\tif (!this._isPlaying) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn this._hitTestItems(mouse.x, mouse.y);\n\t\t};\n\n\t\troad.prototype._hitTestItems = function(x, y) {\n\t\t\tvar combo, i, intersects, item, j, len1, obj, ref, testItems, val, vec, x2, y2;\n\t\t\tif (!this._isPlaying || !this.usableGame()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttestItems = [];\n\t\t\tref = this._items;\n\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\tval = ref[i];\n\t\t\t\tif ((val != null) && val.isHitTarget()) {\n\t\t\t\t\tobj = val.get3dObject();\n\t\t\t\t\tobj.listKey = i;\n\t\t\t\t\ttestItems.push(obj);\n\t\t\t\t}\n\t\t\t}\n\t\t\tx2 = (x / root.MY.myfw.stageWidth()) * 2 - 1;\n\t\t\ty2 = -(y / root.MY.myfw.stageHeight()) * 2 + 1;\n\t\t\tvec = new THREE.Vector3(x2, y2, 0.5);\n\t\t\tvec.unproject(this._camera);\n\t\t\tvec = vec.sub(this._camera.position).normalize();\n\t\t\tthis._hitRay.set(this._camera.position, vec);\n\t\t\tintersects = this._hitRay.intersectObjects(testItems);\n\t\t\tif (intersects.length > 0) {\n\t\t\t\titem = this._items[intersects[0].object.listKey];\n\t\t\t\tif (item != null) {\n\t\t\t\t\tthis._line.addPoint(item.container().position.clone(), item.rank());\n\t\t\t\t\tcombo = this._line.getCombo();\n\t\t\t\t\titem.hitAnimation(combo);\n\t\t\t\t\tthis._lifeUpEffectLing();\n\t\t\t\t\tif (this.onGetItem != null) {\n\t\t\t\t\t\treturn this.onGetItem(item.rank(), combo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\troad.prototype._hideAllItem = function() {\n\t\t\tvar i, j, len1, ref, results, val;\n\t\t\tif (this._items != null) {\n\t\t\t\tref = this._items;\n\t\t\t\tresults = [];\n\t\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\t\tval = ref[i];\n\t\t\t\t\tif (val != null) {\n\t\t\t\t\t\tresults.push(val.hide());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresults.push(void 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t}\n\t\t};\n\n\t\troad.prototype.disposeRoad = function() {\n\t\t\tif (this._mesh != null) {\n\t\t\t\tthis._container.remove(this._mesh);\n\t\t\t\tif (this._geo != null) {\n\t\t\t\t\tthis._geo.dispose();\n\t\t\t\t\tthis._geo = null;\n\t\t\t\t}\n\t\t\t\tthis._mesh = null;\n\t\t\t}\n\t\t\tif (this._nextMesh != null) {\n\t\t\t\tthis._container.remove(this._nextMesh);\n\t\t\t\tif (this._nextGeo != null) {\n\t\t\t\t\tthis._nextGeo.dispose();\n\t\t\t\t\tthis._nextGeo = null;\n\t\t\t\t}\n\t\t\t\treturn this._nextMesh = null;\n\t\t\t}\n\t\t};\n\n\t\troad.prototype.disposeItems = function() {\n\t\t\tvar i, j, len1, ref, val;\n\t\t\tif (this._items != null) {\n\t\t\t\tref = this._items;\n\t\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\t\tval = ref[i];\n\t\t\t\t\tif (val != null) {\n\t\t\t\t\t\tval.dispose();\n\t\t\t\t\t\tthis._items[i] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this._items = [];\n\t\t\t}\n\t\t};\n\n\t\troad.prototype.disposeStgparts = function() {\n\t\t\tvar i, j, len1, ref, val;\n\t\t\tif (this._stgparts != null) {\n\t\t\t\tref = this._stgparts;\n\t\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\t\tval = ref[i];\n\t\t\t\t\tif (val != null) {\n\t\t\t\t\t\tval.dispose();\n\t\t\t\t\t\tthis._stgparts[i] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this._stgparts = [];\n\t\t\t}\n\t\t};\n\n\t\troad.prototype.disposeGround = function() {};\n\n\t\troad.prototype._eCompleteMaxCombo = function(point) {\n\t\t\treturn this._comboMaxEffect.show(point);\n\t\t};\n\n\t\troad.prototype._lifeUpEffectLing = function() {\n\t\t\tvar i, j, len1, ref, results, val;\n\t\t\tref = this._ring;\n\t\t\tresults = [];\n\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\tval = ref[i];\n\t\t\t\tresults.push(val.lifeUp());\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t\treturn road;\n\n\t}"],"file":"about/my_class/road.js","sourceRoot":"/source/"}