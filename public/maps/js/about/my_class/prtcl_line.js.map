{"version":3,"names":[],"mappings":"","sources":["about/my_class/prtcl_line.js"],"sourcesContent":["export default function(superClass) {\n\t\textend(prtclLine, superClass);\n\n\t\tfunction prtclLine() {\n\t\t\tthis._getPosList = bind(this._getPosList, this);\n\t\t\tthis.setColor = bind(this.setColor, this);\n\t\t\tthis.show = bind(this.show, this);\n\t\t\tthis._makePrtcl = bind(this._makePrtcl, this);\n\t\t\tthis.dispose = bind(this.dispose, this);\n\t\t\tthis._updatePrtcl = bind(this._updatePrtcl, this);\n\t\t\tthis.update = bind(this.update, this);\n\t\t\tthis.start = bind(this.start, this);\n\t\t\tprtclLine.__super__.constructor.call(this, {\n\t\t\t\taddScene: false\n\t\t\t});\n\t\t\tthis._prtcl = [];\n\t\t}\n\n\t\tprtclLine.prototype.start = function() {\n\t\t\tprtclLine.__super__.start.call(this);\n\t\t\treturn this._makePrtcl();\n\t\t};\n\n\t\tprtclLine.prototype.update = function() {\n\t\t\tprtclLine.__super__.update.call(this);\n\t\t\tif (this._container.visible) {\n\t\t\t\treturn this._updatePrtcl();\n\t\t\t}\n\t\t};\n\n\t\tprtclLine.prototype._updatePrtcl = function() {\n\t\t\tvar anm, anmLineNum, deadCnt, ease, i, j, len1, mesh, ref, val;\n\t\t\tanmLineNum = 0;\n\t\t\tdeadCnt = 0;\n\t\t\tref = this._prtcl;\n\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\tval = ref[i];\n\t\t\t\tmesh = val.mesh;\n\t\t\t\tanm = val.anm;\n\t\t\t\tif (anm.isShow && ++anm.i >= anm.d) {\n\t\t\t\t\tanmLineNum++;\n\t\t\t\t\tmesh.visible = true;\n\t\t\t\t\tmesh.position.x += anm.g;\n\t\t\t\t\tmesh.material.needsUpdate = true;\n\t\t\t\t\tmesh.rotation.x += anm.rotXSpd;\n\t\t\t\t\tmesh.rotation.y += anm.rotYSpd;\n\t\t\t\t\tmesh.rotation.z += anm.rotZSpd;\n\t\t\t\t\tif (anm.i >= anm.d + anm.dead) {\n\t\t\t\t\t\tease = 0.05;\n\t\t\t\t\t\tif (anm.i >= anm.d + anm.dead + anm.dead2) {\n\t\t\t\t\t\t\tmesh.visible = false;\n\t\t\t\t\t\t\tdeadCnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (deadCnt >= anmLineNum) {\n\t\t\t\treturn this._container.visible = false;\n\t\t\t}\n\t\t};\n\n\t\tprtclLine.prototype.dispose = function() {\n\t\t\treturn prtclLine.__super__.dispose.call(this);\n\t\t};\n\n\t\tprtclLine.prototype._makePrtcl = function() {\n\t\t\tvar anm, b, geometry, i, material, num, obj, results, size, tri;\n\t\t\ti = 0;\n\t\t\tnum = [20, 16][this._device];\n\t\t\tresults = [];\n\t\t\twhile (i < num) {\n\t\t\t\tobj = {};\n\t\t\t\tsize = 1.5;\n\t\t\t\tgeometry = new THREE.Geometry();\n\t\t\t\tgeometry.vertices[0] = new THREE.Vector3(-size * 0.5, size * 0.5, 0);\n\t\t\t\tgeometry.vertices[1] = new THREE.Vector3(size * 0.5, size * 0.5, 0);\n\t\t\t\tgeometry.vertices[2] = new THREE.Vector3(0, -size * 0.5, 0);\n\t\t\t\tgeometry.faces[0] = new THREE.Face3(0, 1, 2);\n\t\t\t\tb = THREE.AdditiveBlending;\n\t\t\t\tmaterial = new THREE.MeshBasicMaterial({\n\t\t\t\t\tcolor: 0xff0000,\n\t\t\t\t\ttransparent: true,\n\t\t\t\t\topacity: 1,\n\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\tblending: b\n\t\t\t\t});\n\t\t\t\ttri = new THREE.Mesh(geometry, material);\n\t\t\t\tthis._container.add(tri);\n\t\t\t\ttri.visible = false;\n\t\t\t\tobj.mesh = tri;\n\t\t\t\tanm = {};\n\t\t\t\tobj.anm = anm;\n\t\t\t\tthis._prtcl.push(obj);\n\t\t\t\tresults.push(i++);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t\tprtclLine.prototype.show = function(to, from, c0, c1) {\n\t\t\tvar anm, color, i, j, len1, mesh, p, pos, ref, scale, val;\n\t\t\tpos = this._getPosList(to, from, c0, c1);\n\t\t\tcolor = new THREE.Color();\n\t\t\tref = this._prtcl;\n\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\tval = ref[i];\n\t\t\t\tmesh = val.mesh;\n\t\t\t\tanm = val.anm;\n\t\t\t\tif (pos[i] != null) {\n\t\t\t\t\tp = pos[i];\n\t\t\t\t\tmesh.visible = false;\n\t\t\t\t\tanm.isShow = true;\n\t\t\t\t\tcolor.setRGB(p.r, p.g, p.b);\n\t\t\t\t\tmesh.material.setValues({\n\t\t\t\t\t\tcolor: color.getHex(),\n\t\t\t\t\t\topacity: 1\n\t\t\t\t\t});\n\t\t\t\t\tmesh.material.needsUpdate = true;\n\t\t\t\t\tif (this._u.hit(4)) {\n\t\t\t\t\t\tscale = this._u.random(1, 10) / 100;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscale = this._u.random(50, 100) / 100;\n\t\t\t\t\t}\n\t\t\t\t\tmesh.scale.set(scale, scale, scale);\n\t\t\t\t\tmesh.rotation.x = this._u.radian(this._u.range(180));\n\t\t\t\t\tmesh.rotation.y = this._u.radian(this._u.range(180));\n\t\t\t\t\tmesh.rotation.z = this._u.radian(this._u.range(180));\n\t\t\t\t\tanm.x = p.x;\n\t\t\t\t\tanm.y = p.y;\n\t\t\t\t\tanm.z = p.z;\n\t\t\t\t\tanm.g = this._u.range(100) / 5000;\n\t\t\t\t\tanm.d = i * 0.1;\n\t\t\t\t\tanm.i = 0;\n\t\t\t\t\tanm.dead = this._conf.LINE_HIDE_INTERVAL[this._device];\n\t\t\t\t\tanm.dead2 = 20;\n\t\t\t\t\tanm.rotXSpd = this._u.range(100) / 100;\n\t\t\t\t\tanm.rotYSpd = this._u.range(100) / 100;\n\t\t\t\t\tanm.rotZSpd = this._u.range(100) / 100;\n\t\t\t\t\tmesh.position.set(anm.x, anm.y, anm.z);\n\t\t\t\t} else {\n\t\t\t\t\tmesh.visible = false;\n\t\t\t\t\tanm.isShow = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prtclLine.__super__.show.call(this);\n\t\t};\n\n\t\tprtclLine.prototype.setColor = function(color) {\n\t\t\tvar i, j, len1, mesh, ref, results, val;\n\t\t\tref = this._prtcl;\n\t\t\tresults = [];\n\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\tval = ref[i];\n\t\t\t\tmesh = val.mesh;\n\t\t\t\tmesh.material.setValues({\n\t\t\t\t\tcolor: color\n\t\t\t\t});\n\t\t\t\tresults.push(mesh.material.needsUpdate = true);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t\tprtclLine.prototype._getPosList = function(to, from, c0, c1) {\n\t\t\tvar anm, d, dx, dy, dz, f, fromColor, i, p, pos, toColor;\n\t\t\tpos = [];\n\t\t\tfromColor = new THREE.Color(c1);\n\t\t\ttoColor = new THREE.Color(c0);\n\t\t\tdx = from.x - to.x;\n\t\t\tdy = from.y - to.y;\n\t\t\tdz = from.z - to.z;\n\t\t\td = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\t\t\tf = this._u.map(d, 0, this._prtcl.length, 0, 300);\n\t\t\tanm = new root._LIBS.animation();\n\t\t\tanm.set({\n\t\t\t\tx: {\n\t\t\t\t\tfrom: from.x,\n\t\t\t\t\tto: to.x\n\t\t\t\t},\n\t\t\t\ty: {\n\t\t\t\t\tfrom: from.y,\n\t\t\t\t\tto: to.y\n\t\t\t\t},\n\t\t\t\tz: {\n\t\t\t\t\tfrom: from.z,\n\t\t\t\t\tto: to.z\n\t\t\t\t},\n\t\t\t\tr: {\n\t\t\t\t\tfrom: fromColor.r,\n\t\t\t\t\tto: toColor.r\n\t\t\t\t},\n\t\t\t\tg: {\n\t\t\t\t\tfrom: fromColor.g,\n\t\t\t\t\tto: toColor.g\n\t\t\t\t},\n\t\t\t\tb: {\n\t\t\t\t\tfrom: fromColor.b,\n\t\t\t\t\tto: toColor.b\n\t\t\t\t},\n\t\t\t\tframe: f,\n\t\t\t\tease: \"linear\"\n\t\t\t});\n\t\t\ti = 0;\n\t\t\twhile (i < f) {\n\t\t\t\tanm.rate(i / f);\n\t\t\t\tp = {\n\t\t\t\t\tx: anm.get(\"x\"),\n\t\t\t\t\ty: anm.get(\"y\"),\n\t\t\t\t\tz: anm.get(\"z\"),\n\t\t\t\t\tr: anm.get(\"r\"),\n\t\t\t\t\tg: anm.get(\"g\"),\n\t\t\t\t\tb: anm.get(\"b\")\n\t\t\t\t};\n\t\t\t\tpos.push(p);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn pos;\n\t\t};\n\n\t\treturn prtclLine;\n\n\t}"],"file":"about/my_class/prtcl_line.js","sourceRoot":"/source/"}