{"version":3,"names":[],"mappings":"","sources":["about/my_class/prtcl_combo.js"],"sourcesContent":["export default function(superClass) {\n\t\textend(prtclCombo, superClass);\n\n\t\tfunction prtclCombo() {\n\t\t\tthis.setColor = bind(this.setColor, this);\n\t\t\tthis.show = bind(this.show, this);\n\t\t\tthis._makePrtcl = bind(this._makePrtcl, this);\n\t\t\tthis.dispose = bind(this.dispose, this);\n\t\t\tthis._updatePrtcl = bind(this._updatePrtcl, this);\n\t\t\tthis.update = bind(this.update, this);\n\t\t\tthis.start = bind(this.start, this);\n\t\t\tprtclCombo.__super__.constructor.call(this, {\n\t\t\t\taddScene: false\n\t\t\t});\n\t\t\tthis._prtcl = [];\n\t\t}\n\n\t\tprtclCombo.prototype.start = function() {\n\t\t\tprtclCombo.__super__.start.call(this);\n\t\t\treturn this._makePrtcl();\n\t\t};\n\n\t\tprtclCombo.prototype.update = function() {\n\t\t\tprtclCombo.__super__.update.call(this);\n\t\t\tif (this._container.visible) {\n\t\t\t\treturn this._updatePrtcl();\n\t\t\t}\n\t\t};\n\n\t\tprtclCombo.prototype._updatePrtcl = function() {\n\t\t\tvar anm, deadCnt, ease, i, j, len1, mesh, ref, showNum, tx, ty, tz, val;\n\t\t\tshowNum = 0;\n\t\t\tdeadCnt = 0;\n\t\t\tref = this._prtcl;\n\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\tval = ref[i];\n\t\t\t\tmesh = val.mesh;\n\t\t\t\tanm = val.anm;\n\t\t\t\tif (anm.isShow && ++anm.i >= anm.d) {\n\t\t\t\t\tshowNum++;\n\t\t\t\t\tmesh.visible = true;\n\t\t\t\t\tanm.p = Math.min(1, anm.p += 0.05);\n\t\t\t\t\ttx = anm.tx0 * (1 - anm.p) + anm.tx1 * anm.p;\n\t\t\t\t\tty = anm.ty0 * (1 - anm.p) + anm.ty1 * anm.p;\n\t\t\t\t\ttz = anm.tz0 * (1 - anm.p) + anm.tz1 * anm.p;\n\t\t\t\t\tease = 0.1;\n\t\t\t\t\tmesh.position.x += (tx - mesh.position.x) * ease;\n\t\t\t\t\tmesh.position.y += (ty - mesh.position.y) * ease;\n\t\t\t\t\tmesh.position.z += (tz - mesh.position.z) * ease;\n\t\t\t\t\tmesh.rotation.x += anm.rotXSpd;\n\t\t\t\t\tmesh.rotation.y += anm.rotYSpd;\n\t\t\t\t\tmesh.rotation.z += anm.rotZSpd;\n\t\t\t\t\tif (anm.i >= anm.dead + anm.d) {\n\t\t\t\t\t\tmesh.visible = false;\n\t\t\t\t\t\tdeadCnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (deadCnt >= showNum) {\n\t\t\t\treturn this._container.visible = false;\n\t\t\t}\n\t\t};\n\n\t\tprtclCombo.prototype.dispose = function() {\n\t\t\treturn prtclCombo.__super__.dispose.call(this);\n\t\t};\n\n\t\tprtclCombo.prototype._makePrtcl = function() {\n\t\t\tvar anm, geometry, i, material, num, obj, results, size, tri;\n\t\t\ti = 0;\n\t\t\tnum = [40, 10][this._device];\n\t\t\tresults = [];\n\t\t\twhile (i < num) {\n\t\t\t\tobj = {};\n\t\t\t\tsize = 3;\n\t\t\t\tgeometry = new THREE.Geometry();\n\t\t\t\tgeometry.vertices[0] = new THREE.Vector3(-size * 0.5, size * 0.5, 0);\n\t\t\t\tgeometry.vertices[1] = new THREE.Vector3(size * 0.5, size * 0.5, 0);\n\t\t\t\tgeometry.vertices[2] = new THREE.Vector3(0, -size * 0.5, 0);\n\t\t\t\tgeometry.faces[0] = new THREE.Face3(0, 1, 2);\n\t\t\t\tmaterial = new THREE.MeshBasicMaterial({\n\t\t\t\t\tcolor: 0xff0000,\n\t\t\t\t\ttransparent: true,\n\t\t\t\t\topacity: 1,\n\t\t\t\t\tside: THREE.DoubleSide,\n\t\t\t\t\tblending: THREE.AdditiveBlending\n\t\t\t\t});\n\t\t\t\ttri = new THREE.Mesh(geometry, material);\n\t\t\t\tthis._container.add(tri);\n\t\t\t\ttri.visible = false;\n\t\t\t\tobj.mesh = tri;\n\t\t\t\tanm = {};\n\t\t\t\tobj.anm = anm;\n\t\t\t\tthis._prtcl.push(obj);\n\t\t\t\tresults.push(i++);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t\tprtclCombo.prototype.show = function(combo) {\n\t\t\tvar anm, i, j, len1, mesh, r, radius, ref, scale, start, useNum, val;\n\t\t\tuseNum = ~~(this._prtcl.length * Math.min(combo / this._conf.MAX_COMBO));\n\t\t\tradius = 70 + 10 * combo;\n\t\t\tstart = this._u.random(0, 360);\n\t\t\tref = this._prtcl;\n\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\tval = ref[i];\n\t\t\t\tmesh = val.mesh;\n\t\t\t\tanm = val.anm;\n\t\t\t\tif (i <= useNum) {\n\t\t\t\t\tmesh.visible = false;\n\t\t\t\t\tanm.isShow = true;\n\t\t\t\t\tif (this._u.hit(2)) {\n\t\t\t\t\t\tscale = this._u.random(1, 10) / 100;\n\t\t\t\t\t\tanm.rotXSpd = this._u.range(100) / 100;\n\t\t\t\t\t\tanm.rotYSpd = this._u.range(100) / 100;\n\t\t\t\t\t\tanm.rotZSpd = this._u.range(100) / 100;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscale = this._u.random(50, 80) / 100;\n\t\t\t\t\t\tanm.rotXSpd = 0;\n\t\t\t\t\t\tanm.rotYSpd = 0;\n\t\t\t\t\t\tanm.rotZSpd = 0;\n\t\t\t\t\t}\n\t\t\t\t\tmesh.scale.set(scale, scale, scale);\n\t\t\t\t\tmesh.rotation.z = this._u.radian(this._u.range(180));\n\t\t\t\t\tanm.x = 0;\n\t\t\t\t\tanm.y = 0;\n\t\t\t\t\tanm.z = 0;\n\t\t\t\t\tanm.p = 0;\n\t\t\t\t\tr = this._u.range(combo * 7);\n\t\t\t\t\tanm.tx0 = Math.cos(this._u.radian(start + 360 / this._prtcl.length * (i + r))) * radius * 0.5;\n\t\t\t\t\tanm.ty0 = Math.sin(this._u.radian(start + 360 / this._prtcl.length * (i + r))) * radius * 0.5;\n\t\t\t\t\tanm.tz0 = Math.cos(this._u.radian(start + 360 / this._prtcl.length * (i + r))) * radius * 0.5;\n\t\t\t\t\tanm.tx1 = -this._u.random(40, 100);\n\t\t\t\t\tanm.ty1 = Math.sin(this._u.radian(start + 360 / this._prtcl.length * i)) * radius;\n\t\t\t\t\tanm.tz1 = Math.cos(this._u.radian(start + 360 / this._prtcl.length * i)) * radius;\n\t\t\t\t\tanm.d = i * 2;\n\t\t\t\t\tanm.i = 0;\n\t\t\t\t\tanm.dead = 20;\n\t\t\t\t\tmesh.position.set(anm.x, anm.y, anm.z);\n\t\t\t\t} else {\n\t\t\t\t\tmesh.visible = false;\n\t\t\t\t\tanm.isShow = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prtclCombo.__super__.show.call(this);\n\t\t};\n\n\t\tprtclCombo.prototype.setColor = function(color) {\n\t\t\tvar i, j, len1, mesh, ref, results, val;\n\t\t\tref = this._prtcl;\n\t\t\tresults = [];\n\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\tval = ref[i];\n\t\t\t\tmesh = val.mesh;\n\t\t\t\tmesh.material.setValues({\n\t\t\t\t\tcolor: color\n\t\t\t\t});\n\t\t\t\tresults.push(mesh.material.needsUpdate = true);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t\treturn prtclCombo;\n\n\t}"],"file":"about/my_class/prtcl_combo.js","sourceRoot":"/source/"}