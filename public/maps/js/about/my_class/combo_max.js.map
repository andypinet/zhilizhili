{"version":3,"names":[],"mappings":"","sources":["about/my_class/combo_max.js"],"sourcesContent":["export default function(superClass) {\n\t\textend(comboMax, superClass);\n\n\t\tfunction comboMax() {\n\t\t\tthis._setDot = bind(this._setDot, this);\n\t\t\tthis._setLine = bind(this._setLine, this);\n\t\t\tthis.show = bind(this.show, this);\n\t\t\tthis.reset = bind(this.reset, this);\n\t\t\tthis.dispose = bind(this.dispose, this);\n\t\t\tthis._updateDot = bind(this._updateDot, this);\n\t\t\tthis._updateLine = bind(this._updateLine, this);\n\t\t\tthis.update = bind(this.update, this);\n\t\t\tthis._makeDot = bind(this._makeDot, this);\n\t\t\tthis._makeLine = bind(this._makeLine, this);\n\t\t\tthis.start = bind(this.start, this);\n\t\t\tcomboMax.__super__.constructor.call(this);\n\t\t\tthis._line = [];\n\t\t\tthis._lineAnm = [];\n\t\t\tthis._dot = [];\n\t\t\tthis._dotAnm = [];\n\t\t\tthis._startDelay = 10;\n\t\t\tthis._startDelayInterval = 6;\n\t\t\tthis._isLineShowed = true;\n\t\t\tthis._isDotShowed = true;\n\t\t}\n\n\t\tcomboMax.prototype.start = function() {\n\t\t\tcomboMax.__super__.start.call(this);\n\t\t\tthis._makeLine();\n\t\t\treturn this._makeDot();\n\t\t};\n\n\t\tcomboMax.prototype._makeLine = function() {\n\t\t\tvar anm, geometry, i, line, material, num, results;\n\t\t\ti = 0;\n\t\t\tnum = this._conf.MAX_COMBO;\n\t\t\tresults = [];\n\t\t\twhile (i < num) {\n\t\t\t\tgeometry = new THREE.TorusGeometry(6, 0.5, 32, 32);\n\t\t\t\tmaterial = new THREE.MeshBasicMaterial({\n\t\t\t\t\tcolor: this._conf.RAINBOW_COLOR[i],\n\t\t\t\t\ttransparent: true,\n\t\t\t\t\topacity: 0,\n\t\t\t\t\tdepthTest: false,\n\t\t\t\t\tblending: THREE.CustomBlending,\n\t\t\t\t\tblendSrc: THREE[this._conf.BLEND[4]],\n\t\t\t\t\tblendDst: THREE[this._conf.BLEND[3]],\n\t\t\t\t\tblendEquation: THREE.AddEquation\n\t\t\t\t});\n\t\t\t\tline = new THREE.Mesh(geometry, material);\n\t\t\t\tline.visible = false;\n\t\t\t\tthis._container.add(line);\n\t\t\t\tthis._line.push(line);\n\t\t\t\tanm = new root._LIBS.animation();\n\t\t\t\tthis._lineAnm.push(anm);\n\t\t\t\tresults.push(i++);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t\tcomboMax.prototype._makeDot = function() {\n\t\t\tvar anm, geometry, i, material, num, obj, results;\n\t\t\ti = 0;\n\t\t\tnum = this._conf.MAX_COMBO;\n\t\t\tresults = [];\n\t\t\twhile (i < num) {\n\t\t\t\tgeometry = new THREE.CircleGeometry(20, 32);\n\t\t\t\tmaterial = new THREE.MeshBasicMaterial({\n\t\t\t\t\tcolor: this._conf.RAINBOW_COLOR[i],\n\t\t\t\t\ttransparent: true,\n\t\t\t\t\topacity: 1,\n\t\t\t\t\tblending: THREE.NormalBlending,\n\t\t\t\t\tdepthTest: false\n\t\t\t\t});\n\t\t\t\tobj = new THREE.Mesh(geometry, material);\n\t\t\t\tthis._container.add(obj);\n\t\t\t\tobj.visible = false;\n\t\t\t\tthis._dot.push(obj);\n\t\t\t\tanm = new root._LIBS.animation();\n\t\t\t\tthis._dotAnm.push(anm);\n\t\t\t\tresults.push(i++);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t\tcomboMax.prototype.update = function() {\n\t\t\tcomboMax.__super__.update.call(this);\n\t\t\tif (!this._isLineShowed || !this._isDotShowed) {\n\t\t\t\tthis._updateLine();\n\t\t\t\tif (this._isLineShowed && this._isDotShowed) {\n\t\t\t\t\treturn this.reset();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tcomboMax.prototype._updateLine = function() {\n\t\t\tvar anm, i, j, len1, lineDeadCnt, ref, scale, val;\n\t\t\tlineDeadCnt = 0;\n\t\t\tref = this._line;\n\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\tval = ref[i];\n\t\t\t\tanm = this._lineAnm[i];\n\t\t\t\tif (anm.isStart()) {\n\t\t\t\t\tval.visible = true;\n\t\t\t\t\tscale = anm.get(\"scale\");\n\t\t\t\t\tval.scale.set(scale, scale, scale);\n\t\t\t\t\tval.material.opacity = anm.get(\"opacity\");\n\t\t\t\t\tif (anm.isCompleted()) {\n\t\t\t\t\t\tlineDeadCnt++;\n\t\t\t\t\t\tval.visible = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lineDeadCnt >= this._line.length) {\n\t\t\t\treturn this._isLineShowed = true;\n\t\t\t}\n\t\t};\n\n\t\tcomboMax.prototype._updateDot = function() {\n\t\t\tvar anm, dotDeadCnt, i, j, len1, ref, scale, val;\n\t\t\tdotDeadCnt = 0;\n\t\t\tref = this._dot;\n\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\tval = ref[i];\n\t\t\t\tanm = this._dotAnm[i];\n\t\t\t\tif (anm.isStart()) {\n\t\t\t\t\tval.visible = true;\n\t\t\t\t\tscale = anm.get(\"scale\");\n\t\t\t\t\tval.scale.set(scale, scale, scale);\n\t\t\t\t\tval.material.opacity = anm.get(\"opacity\");\n\t\t\t\t\tif (anm.isCompleted()) {\n\t\t\t\t\t\tdotDeadCnt++;\n\t\t\t\t\t\tval.visible = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dotDeadCnt >= this._dot.length) {\n\t\t\t\treturn this._isDotShowed = true;\n\t\t\t}\n\t\t};\n\n\t\tcomboMax.prototype.dispose = function() {\n\t\t\treturn comboMax.__super__.dispose.call(this);\n\t\t};\n\n\t\tcomboMax.prototype.reset = function() {\n\t\t\tthis._isLineShowed = true;\n\t\t\treturn this._isDotShowed = true;\n\t\t};\n\n\t\tcomboMax.prototype.show = function(point) {\n\t\t\tcomboMax.__super__.show.call(this);\n\t\t\tif (!this._isSmt) {\n\t\t\t\troot.MY.gl.main.startBrightAnimation([40, 20][this._device], 0, \"easeInExpo\", 0.2);\n\t\t\t}\n\t\t\tthis.reset();\n\t\t\tthis._isLineShowed = false;\n\t\t\treturn this._setLine(point);\n\t\t};\n\n\t\tcomboMax.prototype._setLine = function(point) {\n\t\t\tvar anm, i, j, len1, ref, results, val;\n\t\t\tref = this._line;\n\t\t\tresults = [];\n\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\tval = ref[i];\n\t\t\t\tval.position.copy(point[i]);\n\t\t\t\tval.visible = false;\n\t\t\t\tanm = this._lineAnm[i];\n\t\t\t\tanm.set({\n\t\t\t\t\tscale: {\n\t\t\t\t\t\tfrom: [15, 15][this._device],\n\t\t\t\t\t\tto: 0.01\n\t\t\t\t\t},\n\t\t\t\t\topacity: {\n\t\t\t\t\t\tfrom: 1,\n\t\t\t\t\t\tto: 1\n\t\t\t\t\t},\n\t\t\t\t\tframe: [60, 30][this._device],\n\t\t\t\t\tdelay: this._startDelay + this._startDelayInterval * i,\n\t\t\t\t\tease: \"easeOutExpo\"\n\t\t\t\t});\n\t\t\t\tresults.push(anm.start());\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t\tcomboMax.prototype._setDot = function(point) {\n\t\t\tvar anm, i, j, len1, ref, results, val;\n\t\t\tref = this._dot;\n\t\t\tresults = [];\n\t\t\tfor (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n\t\t\t\tval = ref[i];\n\t\t\t\tval.position.copy(point[i]);\n\t\t\t\tval.visible = false;\n\t\t\t\tanm = this._dotAnm[i];\n\t\t\t\tanm.set({\n\t\t\t\t\tscale: {\n\t\t\t\t\t\tfrom: 0.1,\n\t\t\t\t\t\tto: 6\n\t\t\t\t\t},\n\t\t\t\t\topacity: {\n\t\t\t\t\t\tfrom: 1,\n\t\t\t\t\t\tto: 1\n\t\t\t\t\t},\n\t\t\t\t\tframe: 40,\n\t\t\t\t\tdelay: this._startDelay + i * this._startDelayInterval,\n\t\t\t\t\tease: \"easeOutExpo\"\n\t\t\t\t});\n\t\t\t\tresults.push(anm.start());\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t\treturn comboMax;\n\n\t}"],"file":"about/my_class/combo_max.js","sourceRoot":"/source/"}